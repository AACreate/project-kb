{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"project \"KB\" \u00b6 Project KB supports to the creation, management and aggregation of a distributed, collaborative knowledge base of vulnerabilities that affect open-source software. This repository contains both a tool and vulnerability data . Additionally, the MSR2019 folder contains the package associated with the paper we published at the Mining Software Repository conference in 2019 (see below). Why this project \u00b6 In order to feed Eclipse Steady with fresh data, we have spent a considerable amount of time, in the past few years, mining and curating a knowledge base of vulnerabilities that affect open-source components. We know that other parties have been doing the same, in academia as well as in the industry. From this experience, we have learnt that with the growing size of open source ecosystems and the pace at which new vulnerabilities are discovered, the old approach cannot scale. We are also more and more convinced that vulnerability knowledge-bases about open-source should be open-source themselves and adopt the same community-oriented model that governs the rest of the open-source ecosystem. These considerations have pushed us to release our vulnerability knowledge base in early 2019. In June 2020, we made a further step releasing tool support to make the creation, aggregation, and consumption of vulnerability data much easier. We hope this will encourage more contributors to join our efforts to build a collaborative, comprehensive knowledge base where each party remains in control of the data they produce and of how they aggregate and consume data from the other sources. What can project \"KB\" be used for, in practice \u00b6 (work in progress) Project \"KB\" consists essentially of two things: a tool and a knowledge base. The tool ( kaybee ) allows users to do the following: create vulnerability statements; a vulnerability statement is a plain-text file in yaml format that contains data about a given vulnerability, such as the commits that provide a fix for it, a set of notes and references to related Web pages, a list of open-source components that are directly affected by the vulnerability at hand, and so on. fetch vulnerability statements from one or more remote sources (git repositories) merge the content of multiple sources of statements, based on a conflict resolution policy export the result of the merge operation to a variety of different formats The knowledge base , offers a set of vulnerability statements that can be consumed using the kaybee tool. Getting started \u00b6 Installing the kaybee tool \u00b6 There is nothing to install actually, just download a binary compatible with your operating system, make sure it has execution permissions if applicable, and then run it. Optionally, for your convenience, you may want to make sure that the binary is in your $PATH . For example, in Linux you would put the following line in your .bashrc file: export PATH=$PATH:/usr/local/bin/kaybee (please, make sure you adjust the path to the kaybee binary as necessary) Alternatively, you can clone this repository and build it yourself (you will need go and make ). You can do so with the make command; inspecting the Makefile first is a good idea. Usage \u00b6 Once you have downloaded or built the binary, you can see the list of supported commands with: kaybee --help Documentation \u00b6 Coming soon. Importing vulnerability data in Eclipse Steady \u00b6 The steps that are required to import the knowledge base in Eclipse Steady are described in this tutorial . Further information can be found here . Publications \u00b6 In early 2019, a snapshot of the knowlege base from project \"KB\" was described in: Serena E. Ponta, Henrik Plate, Antonino Sabetta, Michele Bezzi, C\u00e9dric Dangremont, A Manually-Curated Dataset of Fixes to Vulnerabilities of Open-Source Software , MSR, 2019 If you use the dataset for your research work, please cite it as: @inproceedings{ponta2019msr, author={Serena E. Ponta and Henrik Plate and Antonino Sabetta and Michele Bezzi and C\u00b4edric Dangremont}, title={A Manually-Curated Dataset of Fixes to Vulnerabilities of Open-Source Software}, booktitle={Proceedings of the 16th International Conference on Mining Software Repositories}, year=2019, month=May, } MSR 2019 DATA SHOWCASE SUBMISSION : please find here the data and the scripts described in that paper Credits \u00b6 Note that 3 rd party information from NVD and MITRE might have been used as input for compiling this knowledge base. See MITRE's Terms of Use for more information. Features \u00b6 Creation of vulnerability statements Retrieval and reconciliation of statement from multiple repositories, based on user-specified policies Requirements \u00b6 None, the kaybee binary is self-contained. Binary versions for Windows, Linux, MacOS are available for download . Limitations \u00b6 This project is work-in-progress. The vulnerability knowledge base only contains information about vulnerabilities in Java and Python open source components. Known Issues \u00b6 The list of current issues is available here . Feel free to open a new issue if you think you found a bug or if you have a feature request. How to obtain support \u00b6 For the time being, please use GitHub issues both to report bugs and to request help. Documentation and better support channels will come soon. Contributing \u00b6 Vulnerability data \u00b6 A structured process to create and share vulnerability data is work in progress. Until it is defined, we invite you to just create pull requests in order to submit new vulnerability data. Such pull requests should contain a vulnerability identifier, the URL of the source code repository of the affected component and one or more identifiers of the commits used to fix the vulnerability. Contributing code \u00b6 Pull requests are welcome. Please make sure you provide tests for your code, that you can successfully execute make check with no errors and that you include adequate documentation in your contribution. Other non-code contributions \u00b6 Non-code contributions such as documentation, bug reports, etc. are also most appreciated. License \u00b6 Copyright \u00a9 2020 SAP SE or an SAP affiliate company. All rights reserved. This project is licensed under the Apache Software License, v.2 except as noted otherwise in the LICENSE file .","title":"Home"},{"location":"#project-kb","text":"Project KB supports to the creation, management and aggregation of a distributed, collaborative knowledge base of vulnerabilities that affect open-source software. This repository contains both a tool and vulnerability data . Additionally, the MSR2019 folder contains the package associated with the paper we published at the Mining Software Repository conference in 2019 (see below).","title":"project \"KB\""},{"location":"#why-this-project","text":"In order to feed Eclipse Steady with fresh data, we have spent a considerable amount of time, in the past few years, mining and curating a knowledge base of vulnerabilities that affect open-source components. We know that other parties have been doing the same, in academia as well as in the industry. From this experience, we have learnt that with the growing size of open source ecosystems and the pace at which new vulnerabilities are discovered, the old approach cannot scale. We are also more and more convinced that vulnerability knowledge-bases about open-source should be open-source themselves and adopt the same community-oriented model that governs the rest of the open-source ecosystem. These considerations have pushed us to release our vulnerability knowledge base in early 2019. In June 2020, we made a further step releasing tool support to make the creation, aggregation, and consumption of vulnerability data much easier. We hope this will encourage more contributors to join our efforts to build a collaborative, comprehensive knowledge base where each party remains in control of the data they produce and of how they aggregate and consume data from the other sources.","title":"Why this project"},{"location":"#what-can-project-kb-be-used-for-in-practice","text":"(work in progress) Project \"KB\" consists essentially of two things: a tool and a knowledge base. The tool ( kaybee ) allows users to do the following: create vulnerability statements; a vulnerability statement is a plain-text file in yaml format that contains data about a given vulnerability, such as the commits that provide a fix for it, a set of notes and references to related Web pages, a list of open-source components that are directly affected by the vulnerability at hand, and so on. fetch vulnerability statements from one or more remote sources (git repositories) merge the content of multiple sources of statements, based on a conflict resolution policy export the result of the merge operation to a variety of different formats The knowledge base , offers a set of vulnerability statements that can be consumed using the kaybee tool.","title":"What can project \"KB\" be used for, in practice"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installing-the-kaybee-tool","text":"There is nothing to install actually, just download a binary compatible with your operating system, make sure it has execution permissions if applicable, and then run it. Optionally, for your convenience, you may want to make sure that the binary is in your $PATH . For example, in Linux you would put the following line in your .bashrc file: export PATH=$PATH:/usr/local/bin/kaybee (please, make sure you adjust the path to the kaybee binary as necessary) Alternatively, you can clone this repository and build it yourself (you will need go and make ). You can do so with the make command; inspecting the Makefile first is a good idea.","title":"Installing the kaybee tool"},{"location":"#usage","text":"Once you have downloaded or built the binary, you can see the list of supported commands with: kaybee --help","title":"Usage"},{"location":"#documentation","text":"Coming soon.","title":"Documentation"},{"location":"#importing-vulnerability-data-in-eclipse-steady","text":"The steps that are required to import the knowledge base in Eclipse Steady are described in this tutorial . Further information can be found here .","title":"Importing vulnerability data in Eclipse Steady"},{"location":"#publications","text":"In early 2019, a snapshot of the knowlege base from project \"KB\" was described in: Serena E. Ponta, Henrik Plate, Antonino Sabetta, Michele Bezzi, C\u00e9dric Dangremont, A Manually-Curated Dataset of Fixes to Vulnerabilities of Open-Source Software , MSR, 2019 If you use the dataset for your research work, please cite it as: @inproceedings{ponta2019msr, author={Serena E. Ponta and Henrik Plate and Antonino Sabetta and Michele Bezzi and C\u00b4edric Dangremont}, title={A Manually-Curated Dataset of Fixes to Vulnerabilities of Open-Source Software}, booktitle={Proceedings of the 16th International Conference on Mining Software Repositories}, year=2019, month=May, } MSR 2019 DATA SHOWCASE SUBMISSION : please find here the data and the scripts described in that paper","title":"Publications"},{"location":"#credits","text":"Note that 3 rd party information from NVD and MITRE might have been used as input for compiling this knowledge base. See MITRE's Terms of Use for more information.","title":"Credits"},{"location":"#features","text":"Creation of vulnerability statements Retrieval and reconciliation of statement from multiple repositories, based on user-specified policies","title":"Features"},{"location":"#requirements","text":"None, the kaybee binary is self-contained. Binary versions for Windows, Linux, MacOS are available for download .","title":"Requirements"},{"location":"#limitations","text":"This project is work-in-progress. The vulnerability knowledge base only contains information about vulnerabilities in Java and Python open source components.","title":"Limitations"},{"location":"#known-issues","text":"The list of current issues is available here . Feel free to open a new issue if you think you found a bug or if you have a feature request.","title":"Known Issues"},{"location":"#how-to-obtain-support","text":"For the time being, please use GitHub issues both to report bugs and to request help. Documentation and better support channels will come soon.","title":"How to obtain support"},{"location":"#contributing","text":"","title":"Contributing"},{"location":"#vulnerability-data","text":"A structured process to create and share vulnerability data is work in progress. Until it is defined, we invite you to just create pull requests in order to submit new vulnerability data. Such pull requests should contain a vulnerability identifier, the URL of the source code repository of the affected component and one or more identifiers of the commits used to fix the vulnerability.","title":"Vulnerability data"},{"location":"#contributing-code","text":"Pull requests are welcome. Please make sure you provide tests for your code, that you can successfully execute make check with no errors and that you include adequate documentation in your contribution.","title":"Contributing code"},{"location":"#other-non-code-contributions","text":"Non-code contributions such as documentation, bug reports, etc. are also most appreciated.","title":"Other non-code contributions"},{"location":"#license","text":"Copyright \u00a9 2020 SAP SE or an SAP affiliate company. All rights reserved. This project is licensed under the Apache Software License, v.2 except as noted otherwise in the LICENSE file .","title":"License"},{"location":"dev_docs/","text":"Coming soon...","title":"Developer docs"},{"location":"faq/","text":"Frequently Asked Questions (F.A.Q.) \u00b6 Troubleshooting \u00b6 Coming soon... Misc \u00b6 What is the relation of project \"KB\" with Eclipse Steady? Eclipse Steady needs code-level data about how vulnerabilities (basically, which commit in which repository fix which vulnerability). Project \"KB\" promotes a collaborative approach to curating such data.","title":"FAQ"},{"location":"faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (F.A.Q.)"},{"location":"faq/#troubleshooting","text":"Coming soon...","title":"Troubleshooting"},{"location":"faq/#misc","text":"What is the relation of project \"KB\" with Eclipse Steady? Eclipse Steady needs code-level data about how vulnerabilities (basically, which commit in which repository fix which vulnerability). Project \"KB\" promotes a collaborative approach to curating such data.","title":"Misc"},{"location":"getting_started/","text":"Coming soon...","title":"Getting started"},{"location":"team/","text":"Coming soon...","title":"Team"},{"location":"user_guide/","text":"User guide \u00b6 Goals \u00b6 The goal of project \"KB\" is promote and enable a community-driven approach to the creation and consumption of information on vulnerabilities affecting open-source software. This goal is pursued by developing a tool ( kaybee ) and by maintaining a knowledge base that can be used as the starting point of a larger, global, collaborative knowledge base maintained by distinct independent parties (develpers of open-source or commercial projects, security researchers). The data from this emerging knowledge base can be aggregated by each consumer based on their preferences (e.g., which sources to trust, how to reconcile conflicting data about the same vulnerability). This distributed management model is realized by building on the functionality provided by source code repository version control (git) and is described in the following. In particular, this document covers: Statements : how vulnerability data is captured in a format that is human-readable and machine-readable at the same time Contribution : how one can contribute with new statements or with incremental updates to existing statements Consumption : how one can aggregate and reconcile vulnerability data Statements \u00b6 A statement can contain two types of variables: exclusive : if two statements have a different exclusive variable, it will be considered as conflicting. cumulative : if two statements have a different cumulative variable, it can be soft merged without major issues. A statement can have the following structure: # version of the document store (required) # the apiVersion allows for different implementation/data structure # to coexist in the document store apiVersion : v1 # textual vulnerability description (optional) references : # list of links and the appropriate description to comprehensive vulnerability information (optional) # [cumulative] # # Note that a description has to be linked to a reference - reference : {{ bug_reference_1 }} description : {{ bug_description_1 }} # list of affected libraries and their corresponding fix commit # [cumulative] if different repositories # [exclusive] if same repositories but different fix_commit fix : - repo : {{ source_code_repository }} branch : {{ branch_code_repository }} commit : {{ commit_addressing_CVE }} Contribution \u00b6 Each contributor maintain their own distinct repository in which they issue statements regarding a CVE affecting certain libraries. The repository structure is the following: \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 cve_id1 \u2502 \u2502 \u2514\u2500\u2500 statement.yaml \u2502 \u2514\u2500\u2500 cve_id2 \u2502 \u2514\u2500\u2500 statement.yaml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 signature \u2514\u2500\u2500 pub_gpg_key_1.asc \u2514\u2500\u2500 pub_gpg_key_2.asc Every statement is nested under the data directory and their separate folder defined by their cve id (lower cased). In each repo, a statement can be declared using a file named statement.yaml . The repository can also be signed by publishing the public signature in the signature directory, in which case, every commit regarding a particular statement must also be signed. Once this repository structure is respected, the actors can chose two modes of contribution: Manual : manually add a statement to the version control and sign if required Automatic : using a content export software, periodically update the repository from an export of the current running database. The vulnerabilities can then be filtered using a series of user defined policy to exclude certain bugs (for instance internal ones). The automatic export configuration can be defined using the following yaml structure: # rest-backend url (hostname of the component that's meant # to interface with the database). It is not recommended # to define it here but in the environment variable VULAS_BACKEND # in order to not publish the internal backend URL backend : {{ rest-backend url }} # use a list of different regexes to filter bugs based on their parameters # if two parameters are in the same item, it is considered as an AND # each parameters in the exclude list is considered as an OR # denylist of bugs to be published export_denylist : # attribute being in { description, references, cve_id, contributor } { attribute }: # list of regex that should be excluded from the database export - \".*\" Consumption \u00b6 Consuming the document store can be summarize by the schema below: Multiple repositories (which in this case is a database) can contribute to the source consumption. Each of this repository will be cloned locally and kept up to date with their remote periodically. Then, through aggregated through a content consumption software in order to be loaded into the vulnerability database. In order to allow users to define which vulnerability they would like to load into the database, a set of cumulative policies can be defined: Ordered list of trusted repositories : assign a priority for each of the source repositories. If conflict were to occur, the merge operation will prioritize the one with higher prio. Timestamp based : prioritize latest bug statements Maturity : prioritize signed commits Denylist : ignore statements regarding certain bugs This can be defined using the following yaml file structure: sources : # the order of this list defines the ordered list of trusted repos 1 : repo : {{ repository_1 url }} branch : {{ branch_1 }} # if signed set to true, ignores all unsigned commits # defaults to false if not set signed : true 2 : repo : {{ repository_2 url }} branch : {{ branch_2 }} 3 : # multiple vulnerability databases can coexist within the same repo # therefore the branch indicator is required repo : {{ repository_1 url }} branch : {{ branch_2 }} # denylist of bugs to be imported import_denylist : # attribute being in { description, references, cve_id, contributor } { attribute }: # list of regex that should be included in the database # defaults to only the vulnerability-assessment-tool team contributors - \".*\" policies : # Defines the series of policies to be applied sequentially # merge strategies if conflicting statements # available are: # - soft: attempt soft merge of cumulative declarations # - priority: if conflict, take the most trusted # - internal: if conflict, always take own statement # - latest: if conflict, take the latest statement # # merge strategies are applied sequentially, so if the first # cannot decide, the second one gets applied and so on. # # A soft merge of cumulative attributes is always applied first 1 : \"priority\" 2 : \"latest\" # prioritize latest statements Before the data is loaded into the vulnerability database, a \"transaction log\" (the result of the merge operation between different statements) is stored in a cache directory (most likely $HOME/.kbsync ). Its structure is strictly similar to a statement but with informations regarding authors behind the commit: # version of the document store (required) # the apiVersion allows for different implementation/data structure # to coexist in the document store apiVersion : v1 # textual vulnerability description (optional) references : # list of links and the appropriate description to comprehensive vulnerability information (optional) # [cumulative] # # Note that a description has to be linked to a reference - reference : {{ bug_reference_1 }} description : {{ bug_description_1 }} metadata : repository : {{ source_repository }} branch : {{ source_repository_branch }} commit : {{ commit_id of the change }} key : {{ public_key_1 }} # truncated hash of the pgp key # list of affected libraries and their corresponding fix commit # [cumulative] if different repositories # [exclusive] if same repositories but different fix_commit fix : - repo : {{ source_code_repository }} commit : {{ commit_addressing_CVE }} metadata : repository : {{ source_repository }} branch : {{ source_repository_branch }} commit : {{ commit_id of the change }} key : {{ public_key_1 }} # truncated hash of the pgp key","title":"User guide"},{"location":"user_guide/#user-guide","text":"","title":"User guide"},{"location":"user_guide/#goals","text":"The goal of project \"KB\" is promote and enable a community-driven approach to the creation and consumption of information on vulnerabilities affecting open-source software. This goal is pursued by developing a tool ( kaybee ) and by maintaining a knowledge base that can be used as the starting point of a larger, global, collaborative knowledge base maintained by distinct independent parties (develpers of open-source or commercial projects, security researchers). The data from this emerging knowledge base can be aggregated by each consumer based on their preferences (e.g., which sources to trust, how to reconcile conflicting data about the same vulnerability). This distributed management model is realized by building on the functionality provided by source code repository version control (git) and is described in the following. In particular, this document covers: Statements : how vulnerability data is captured in a format that is human-readable and machine-readable at the same time Contribution : how one can contribute with new statements or with incremental updates to existing statements Consumption : how one can aggregate and reconcile vulnerability data","title":"Goals"},{"location":"user_guide/#statements","text":"A statement can contain two types of variables: exclusive : if two statements have a different exclusive variable, it will be considered as conflicting. cumulative : if two statements have a different cumulative variable, it can be soft merged without major issues. A statement can have the following structure: # version of the document store (required) # the apiVersion allows for different implementation/data structure # to coexist in the document store apiVersion : v1 # textual vulnerability description (optional) references : # list of links and the appropriate description to comprehensive vulnerability information (optional) # [cumulative] # # Note that a description has to be linked to a reference - reference : {{ bug_reference_1 }} description : {{ bug_description_1 }} # list of affected libraries and their corresponding fix commit # [cumulative] if different repositories # [exclusive] if same repositories but different fix_commit fix : - repo : {{ source_code_repository }} branch : {{ branch_code_repository }} commit : {{ commit_addressing_CVE }}","title":"Statements"},{"location":"user_guide/#contribution","text":"Each contributor maintain their own distinct repository in which they issue statements regarding a CVE affecting certain libraries. The repository structure is the following: \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 cve_id1 \u2502 \u2502 \u2514\u2500\u2500 statement.yaml \u2502 \u2514\u2500\u2500 cve_id2 \u2502 \u2514\u2500\u2500 statement.yaml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 signature \u2514\u2500\u2500 pub_gpg_key_1.asc \u2514\u2500\u2500 pub_gpg_key_2.asc Every statement is nested under the data directory and their separate folder defined by their cve id (lower cased). In each repo, a statement can be declared using a file named statement.yaml . The repository can also be signed by publishing the public signature in the signature directory, in which case, every commit regarding a particular statement must also be signed. Once this repository structure is respected, the actors can chose two modes of contribution: Manual : manually add a statement to the version control and sign if required Automatic : using a content export software, periodically update the repository from an export of the current running database. The vulnerabilities can then be filtered using a series of user defined policy to exclude certain bugs (for instance internal ones). The automatic export configuration can be defined using the following yaml structure: # rest-backend url (hostname of the component that's meant # to interface with the database). It is not recommended # to define it here but in the environment variable VULAS_BACKEND # in order to not publish the internal backend URL backend : {{ rest-backend url }} # use a list of different regexes to filter bugs based on their parameters # if two parameters are in the same item, it is considered as an AND # each parameters in the exclude list is considered as an OR # denylist of bugs to be published export_denylist : # attribute being in { description, references, cve_id, contributor } { attribute }: # list of regex that should be excluded from the database export - \".*\"","title":"Contribution"},{"location":"user_guide/#consumption","text":"Consuming the document store can be summarize by the schema below: Multiple repositories (which in this case is a database) can contribute to the source consumption. Each of this repository will be cloned locally and kept up to date with their remote periodically. Then, through aggregated through a content consumption software in order to be loaded into the vulnerability database. In order to allow users to define which vulnerability they would like to load into the database, a set of cumulative policies can be defined: Ordered list of trusted repositories : assign a priority for each of the source repositories. If conflict were to occur, the merge operation will prioritize the one with higher prio. Timestamp based : prioritize latest bug statements Maturity : prioritize signed commits Denylist : ignore statements regarding certain bugs This can be defined using the following yaml file structure: sources : # the order of this list defines the ordered list of trusted repos 1 : repo : {{ repository_1 url }} branch : {{ branch_1 }} # if signed set to true, ignores all unsigned commits # defaults to false if not set signed : true 2 : repo : {{ repository_2 url }} branch : {{ branch_2 }} 3 : # multiple vulnerability databases can coexist within the same repo # therefore the branch indicator is required repo : {{ repository_1 url }} branch : {{ branch_2 }} # denylist of bugs to be imported import_denylist : # attribute being in { description, references, cve_id, contributor } { attribute }: # list of regex that should be included in the database # defaults to only the vulnerability-assessment-tool team contributors - \".*\" policies : # Defines the series of policies to be applied sequentially # merge strategies if conflicting statements # available are: # - soft: attempt soft merge of cumulative declarations # - priority: if conflict, take the most trusted # - internal: if conflict, always take own statement # - latest: if conflict, take the latest statement # # merge strategies are applied sequentially, so if the first # cannot decide, the second one gets applied and so on. # # A soft merge of cumulative attributes is always applied first 1 : \"priority\" 2 : \"latest\" # prioritize latest statements Before the data is loaded into the vulnerability database, a \"transaction log\" (the result of the merge operation between different statements) is stored in a cache directory (most likely $HOME/.kbsync ). Its structure is strictly similar to a statement but with informations regarding authors behind the commit: # version of the document store (required) # the apiVersion allows for different implementation/data structure # to coexist in the document store apiVersion : v1 # textual vulnerability description (optional) references : # list of links and the appropriate description to comprehensive vulnerability information (optional) # [cumulative] # # Note that a description has to be linked to a reference - reference : {{ bug_reference_1 }} description : {{ bug_description_1 }} metadata : repository : {{ source_repository }} branch : {{ source_repository_branch }} commit : {{ commit_id of the change }} key : {{ public_key_1 }} # truncated hash of the pgp key # list of affected libraries and their corresponding fix commit # [cumulative] if different repositories # [exclusive] if same repositories but different fix_commit fix : - repo : {{ source_code_repository }} commit : {{ commit_addressing_CVE }} metadata : repository : {{ source_repository }} branch : {{ source_repository_branch }} commit : {{ commit_id of the change }} key : {{ public_key_1 }} # truncated hash of the pgp key","title":"Consumption"}]}